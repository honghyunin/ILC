# Spring MVC Thread Pool Life Cycle

1. 스레드 풀 생성: **스프링 애플리케이션이 시작될 때 스레드 풀 객체를 생성**합니다. 스레드 풀은 일반적으로 스프링 설정 파일에서 정의되며, **스프링 컨테이너가 스레드 풀 빈을 생성**하고 미리 설정된 **최소 및 최대 스레드 수를 할당**합니다.
2. 스레드 풀 초기화: 스레드 풀 객체가 생성되면, 스레드 풀의 초기화 작업이 수행됩니다. 스레드 풀 초기화 작업은 **스레드 풀에 필요한 모든 객체 및 변수를 초기화**하고, 스레드 풀이 사용할 수 있는 상태가 되도록 준비합니다.
3. 스레드 풀 사용: 애플리케이션 실행 중에, 스프링 MVC가 들어오는 요청을 처리하기 위해 스레드 풀을 사용합니다. 이 단계에서, 스레드 풀은 할당된 스레드를 사용하여 요청을 처리하고, 요청이 완료되면 다시 사용 가능한 스레드로 반환됩니다.
4. 스레드 풀 종료: **스프링 애플리케이션이 종료될 때**, 스레드 풀 객체는 **종료 작업을 수행**합니다. 스레드 풀 종료 작업은 **스레드 풀이 사용 중인 모든 스레드를 종료**하고, **모든 자원을 해제**하는 등 스레드 풀이 정리될 수 있도록 합니다.

# Blocking WebClient API 호출

1. WebClient 객체 생성: 스프링 애플리케이션이 시작될 때, WebClient 객체를 생성합니다.
2. 스레드 풀 생성: WebClient는 내부적으로 Netty의 이벤트 루프와 스레드 풀을 사용하지 않고, Java의 기본 스레드 풀을 사용합니다.
3. 외부 API 호출: WebClient를 사용하여 외부 API를 호출할 때마다, Java의 기본 스레드 풀에서 새로운 스레드가 생성되어 할당됩니다. 이때 **스레드 풀은 동기 방식**으로 **외부 API 호출 작업을 수행합니다. 이러한 blocking 방식으로 외부 API 호출을 수행하면, 스레드 풀의 자원이 효율적으로 사용되지 않으며, 대규모 트래픽에서는 매우 비효율적**입니다.
4. 외부 API 호출 완료: 외부 API 호출이 완료되면, 사용한 스레드는 Java의 기본 스레드 풀로 반환됩니다.
5. 스레드 풀 종료: 스프링 애플리케이션이 종료될 때, Java의 기본 스레드 풀 객체는 종료 작업을 수행합니다.

# Thread Pool의 자원을 효율적으로 사용 불가능한 이유

1. 스레드 생성과 종료 오버헤드: blocking 방식으로 외부 API 호출을 처리할 때마다 스레드를 생성하고 종료합니다. 스레드 생성과 종료에는 시간과 자원이 소모되므로, 스레드 풀이 제공하는 재사용 기능을 제대로 활용하지 못합니다.
2. 스레드 생성 제한: 스레드 풀은 제한된 개수의 스레드를 생성하여 작업을 처리합니다. blocking 방식으로 외부 API 호출을 처리할 때 스레드를 생성하면서, 이를 다른 작업에 할당할 수 없게 됩니다. 이로 인해 스레드 풀이 제공하는 동시성 처리 기능을 제대로 활용하지 못합니다.
3. 네트워크 대기 시간: blocking 방식으로 외부 API 호출을 처리할 때, 해당 **API의 응답을 기다리는 동안 스레드는 대기 상태에 있게 됩니다**. 이는 스레드 풀이 제공하는 다른 작업의 처리 속도를 저하시키고, 스레드 풀이 처리할 수 있는 요청의 수를 제한합니다.

따라서, blocking 방식으로 WebClient를 사용하여 외부 API를 호출하면, 스레드 풀의 자원을 효율적으로 사용하지 못하게 됩니다. 이는 대규모 트래픽에서 성능 문제를 야기할 수 있으므로, 비동기(non-blocking) 방식으로 WebClient를 사용하여 외부 API를 호출하는 것이 좋습니다.

# Coroutine Dispatchers.IO가 성능을 끌어올릴 수 있는 이유

일반적으로 I/O 작업은 CPU 보다 I/O 처리 장치에 의존적이기 때문에 CPU 코어가 대기하는 시간을 최소화하여 성능을 향상 시킬 수 있다