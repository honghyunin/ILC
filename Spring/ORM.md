# ORM
- ORM (Object-relatinal mapping) : 객체 지향 프로그래밍에선 ``Class``를 사용하고, 관계형 데이터베이스는 ``Table``을 사용합니다.  여기서 **객체 모델과 관계형 모델간에 불일치가 존재하는데 이 객체관의 관계를 바탕으로 SQL을 자동 생성하여 불일치를 해결 하는 것이 ``ORM``입니다.**

**Object** ← 매핑 → **DB데이터** 에서 매핑의 역할을 하는 것이 ORM이라 할 수 있습니다.

# ORM 장점

- **객체 지향적 코드로 인해 더 직관적이고 비즈니스 로직에 집중할 수 있도록 도와줍니다.**
    - CRUD를 위한 긴 SQL 문장을 작성할 필요가 없습니다. ( 쿼리 작성을 안한다는 것은 아닙니다.)
    - 각 객체(Model)별로 코드를 작성하여 가독성을 높여 줍니다
    - SQL의 절차적 접근이 아닌 객체적인 접근으로 생산성을 높여줍니다.
- **재사용 및 유지보수의 편리성이 증가합니다.**
    - 매핑 정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있습니다.
    - ORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능합니다.
- **DBMS에 대한 종속성이 줄어든다**
    - 대부분의 ORM은 DB에 종속적이지 않습니다.
    - 개발자는 Object에 집중함으로 DBMS를 교체하는 극단적인 작업에도 비교적 적은 리스크와 시간이 소요됩니다.
    - 종속적이지 않다는 것은 구현 방법 뿐만 아니라 많은 솔루션에서 자료형 타입까지 유효하다.
- 종속성 : 프로그램 구조가 데이터 구조에 영향을 받는 것을 의미함.

# ORM 단점

- **완벽한 ORM만으로는 구현하기가 어렵다.**
    - 사용하기에는 편하지만 설계에는 매우 신중해야 합니다.
    - 프로젝트의 복잡성이 높아질 경우 난이도 또한 올라갈 수 있습니다.
    - 잘못 구현된 경우 속도 저하 및 심한 경우 일관성이 무너지는 문제점이 생길 수 있습니다.
- **프로시저가 많은 시스템에서는 ORM의 객체 지향적인 장점을 활용하기 어렵다.**
    - 이미 프로시저가 많은 시스템에서는 다시 객체로 바꿔야 하며, 그 과정에서 생산성 저하 혹은 리스크가 발생할 수 있습니다.
- 프로시저 : 특정 작업을 위한 프로그램의 일부. 함수와 같은 의미)


# 참고 사이트


- [ORM 이란?](https://velog.io/@sms8377/Database-ORM%EC%9D%B4%EB%9E%80)