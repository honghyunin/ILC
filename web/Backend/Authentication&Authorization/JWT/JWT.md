# JWT (Json Web Token)

## 💰 JWT란?
- JWT는 클라이언트와 서버, 서비스와 서비스 사이 통신 시 권한 인가(Authorization)를 위해 사용되는 토큰입니다. 
- URL에 대해 안전한 문자열로 구성되어 있기 떄문에 HTTP 어디든 (URL, Header) 위치할 수 있습니다.

# JWT 용도

- 회원 인증 : 로그인 > 토큰 발급 > 유저의 권한 여부 확인
- 정보 교류 : 토큰 생성자 signature 포함(토큰의 주인이 표기되어있음).
    - 양자간 데이터 교환에 무결성을 검증함

# JWT 특징

- Self-Contained(자기 포함) 방식 > 모든 정보가 토큰에 담김
- URL-safe JSON (url로 이용할 수 있는 문자로만 구성)
- HMAC(해싱된 값과 원본 값을 비교하여 변화를 확인하는 방식)에 사용되는 signature에 비밀키, 공개키를 모두 사용할 수 있다.
    - MAC : 원본 메시지와 전달된 메시지를 비교하여 변화를 확인하는 방식(Message Authentication Code)이다.
- JSON에는 ``\n``등의 개행 문자가 존재하므로 BASE64인코딩을 통해  하나의 문자열을 변환한다.

# 장점

- stateless 적합 : 토큰은 클라이언트 사이드(프론트엔드 라고도 함)에 저장되므로 stateless 기반 서비스에 적합하다
    - **stateless : Steateless '구조'는 server의 응답이 client와의 세션 '상태'와 독립적**

    장점 : 서버가 client 정보를 저장관리 하지 않으므로 **Scaling이 자유로움 Stateless 구조에서 server는 단순히 요청이 오면 응답을 보내는 역할만 수행하며, 세션관리는 client에게 책임이 있다.**

- scalability : 서버기반 인증시스템에 비해서 서버의 scalability(확장성)이 높음
- 보안성 : 세션 인증을 위한 쿠키 전달이 필요 없으므로 보안성 향상
- extensibility : scalability와는 조금 다른 확장성, 서버의 확장성이 아닌 로그인이 사용되는 분야, 토큰에 포함되는 정보의 종류 등에 대한 확장성이 높다
- CORS : 어떤 디바이스와 도메인에서도 토큰이 유효하면 정상적으로 처리됨
- 다양한 환경과 언어를 지원

# 단점

- 클라이언트 사이드에 저장되므로 DB에서 사용자 정보가 조작되더라도 토큰에 직접 적용하기가 불가능하며 토큰을 새로 발행해야만 한다
    - 왜냐하면 토큰을 발급할 때에는 DB에서 내용을 가져오는데 그 이후에 DB의 값이 변조되면 새 토큰을 발급 받기전까지는 이전 값 그대로 가지고 있기 때문
- 서비스가 커지면 토큰이 필요로하는 데이터가 커져 토큰이 커지고 이에 따라 매 HTTP요청의 트래픽 양에 영향을 미칠 수 있다
- Header와 Payload가 단순히 BASE64로 인코딩되었기 때문에 클라이언트 사이드에 토큰 내부의 정보가 노출된다


# 🎲 JWT 토큰 구성

![JWT 구성](/images/jwt구성.png)

- JWT는 세 부분으로 나눠지며, 각 부분은 점으로 구분하여 위 사진과 같이 표현됩니다.


1. Header는 토큰의 타입과 해시 암호화 알고리즘으로 구성되있습니다. 
    - 첫 번째는 토큰의 유형을 나타내고, 두 번째는 해쉬 알고리즘을 나타내는 부분입니다.
2. Payload는 토큰에 담을 클레임(Claim) 정보를 포함하고 있습니다. 이 클레임은 name / value 로 한 쌍을 이뤄져있습니다. 또한 토큰에는 여러개의 클레임 들을 넣을 수 있습니다. 클레임의 정보는 등록된 (registered) 클레임, 공개 (public) 클레임, 비공개 (private) 클레임으로 세 종류가 있습니다.
    - 토큰의 페이로드에는 토큰에서 사용할 정보의 조각들인 클레임(Claim)이 담겨 있습니다. 클레임은 3가지로 나뉘며, JSON(Key/Value) 형태로 다수의 정보를 넣을 수 있습니다.

    2.1 등록된 클레임(Registered Claim)

    등록된 클레임은 토큰 정보를 표현하기 위해 이미 정해진 종류의 데이터들로, 모두 선택적으로 작성이 가능하여 사용할 것을 권장합니다. 또한 JWT를 간결하게 하기 위해서는 key는 모두 길이 3의 문자열로 표시합니다. 


    ```
    iss: 토큰 발급자(issuer)

    sub: 토큰 제목(subject)

    aud: 토큰 대상자(audience)

    exp: 토큰 만료 시간(expiration), NumericDate 형식으로 되어 있어야 함 ex) 1480849147370

    nbf: 토큰 활성 날짜(not before), 이 날이 지나기 전의 토큰은 활성화되지 않음

    iat: 토큰 발급 시간(issued at), 토큰 발급 이후의 경과 시간을 알 수 있음

    jti: JWT 토큰 식별자(JWT ID), 중복 방지를 위해 사용하며, 일회용 토큰(Access Token) 등에 사용
    ```

    2.2 공개 클레임(Public CLaim)

    해당 토큰이 사용되는 엔드포인트 또는 웹 페이지를 명시하는 클레임 토큰의 충돌 방지를 위해 클레임의 키를 URL 포멧을 사용합니다.

    ```javaScript
    {"https://hyunin.co.kr":true}
    ```

    2.3 비공개 클레임(Private Claim)
    서버와 클라이언트 사이에 임의로 지정한 정보를 토큰에 저장하여 전달하기로 협의된 커스텀 클레임입니다.  

    ```javaScript
    {"token_type":access}
    ```

    3. Signature
    `` Signature 부분에는 {Header(Base64).Playload(Base64)} 형태를 
    Header의 alg에 명시된 해시 알고리즘으로 해시한 HMAC를 BASE64로 인코딩한 값입니다.

# JWT 작동과정

1. 사용자가 ID와 PASSWORD를 입력하여 로그인 시도합니다.
2. 서버는 요청을 확인하고 secret key를 통해 Acess token을 발급합니다.
3. JWT 토큰을 클라이언트에 전달합니다.
4. 클라이언트에서 API를 요청할 때 클라이언트가 _Authorization header_(인증 토큰을 서버로 보낼 때 사용하는 헤더)에 Access token을 담아서 보냅니다.
5. 서버는 JWT Signature를 체크하고 Payload로부터 사용자 정보를 확인해 데이터를 반환합니다.
6. 클라이언트의 로그인 정보를 서버 메모리에 저장하지 않기 때문에 토큰기반 인증 메커니즘을 제공합니다.
인증이 필요한 경로에 접근할 때 서버 측은 Authorization 헤더에 유효한 JWT 또는 존재하는 지 확인합니다.
JWT에는 필요한 모든 정보를 토큰에 포함하기 때문에 DB와 같은 서버와의 커뮤니케이션 오버 헤드를 최소화할 수 있습니다.
Cross-Origin Resource Sharing(서로 다른 origin 간 HTTP Req가 가능하도록 해주는 표준입니다.)는 쿠키를 사용하지 않기 때문에 JWT를 채용 한 인증 메커니즘은 두 도메인에서 API를 제공하더라도 문제가 발생하지 않습니다.
_처음 사용자를 등록할 때 Access token과 Refres token이 모두 발급되어야 합니다._


