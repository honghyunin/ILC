# JVM 메모리 구조
자바는 운영체제 종류, 플랫폼에 상관없이 독립적으로 실행할 수 있도록 해줍니다.

> jvm은 시스템으로부터 프로그램을 수행하는데 필요한 메모리를 할당 받고, 용도에 따라 여러 영역으로 나누어 관리합니다. 총 5가지의 영역으로 나누어집니다.

## 메모리 구조를 알아야하는 이유

어플리케이션 코드의 성능이 뛰어나도 메모리 관리를 제대로 하지 않으면 어플리케이션의 성능이 떨어질 수 있습니다. 따라서 메모리 구조를 파악하고 한정된 메모리를 효율적으로 사용해야 합니다.


## 자바 실행 과정

![Java Execution Process](/images/JVM.png)

### Java Compoiler 
Java Source 파일을 바이트 코드로 바꿔 .class 파일 생성 

### Class Loader
**JVM내로 클래스 파일을 로드**하고, **링크를 통해 배치 작업**을 수행하는 모듈입니다. 
런타임 시에 동적으로 클래스를 로드합니다.

### Execution Engine
**Runtime Data Area에 배치된 바이트 코드들을 명령어 단위로 읽어 실행합니다.**
최초 JVM이 나왔을 당시에는 인터프리터 방식으로 속도가 느리다는 단점이 있었지만,
JIT 컴파일러 방식으로 단점을 보완했습니다.

___JIT__ 는 바이트 코드를 어셈블러 같은 네이티브 코드로 바꿈으로써 실행이 빠릅니다._

### Garbage Collector 
힙 메모리 영역에 생성된 객체(인스턴스)의 생존여부를 판단해서 더 이상 참조되지 않는 객체의 메모리를 해제

#### Runtime Data Area
**JVM의 메모리 영역** 어플리케이션을 실행할 때 사용되는 데이터를 저장하는 영역.

![Runtime Data Area](/images/DataArea.png)


#### Method area
모든 쓰레드가 공유하는 메모리 영역입니다.
메소드 영역은 클래스, 인터페이스, 메소드, 필드, Static 변수 등의 바이트 코드를 보관합니다. 
시작 시에 생성되서 종료될 때까지 존재하기에 전역변수를 남용할 경우 메모리 초과 위험이 있습니다.

#### Heap area

모든 쓰레드가 공유하며, new 키워드로 생성된 객체와 배열이 생성되는 영역입니다.
또한, 메소드 영역에 로드된 클래스만 생성 가능하고 GC가 참조되지 않는 메모리를 확인하고 제거하는 영역입니다.

#### Stack area
메소드 호출시에 각각의 스택 프레임(메서드만을 위한 공간)을 생성(push)하고 지역변수, 매개변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장합니다.
메서드 수행이 끝나면 프레임 별로 삭제합니다.

#### PC register
쓰레드가 시작할 때 생성될 때 동시에 생성되는 영역입니다.
쓰레드가 실행할 명령에 대한 기록을 하는 부분으로 현재 실행중인 JVM 주소를 저장합니다.

#### Native method stack
자바 외 언어로 작성된 네이티브 코드를 위한 메모리 영역입니다.
_Java Native Interface를 통해 호출되는 C/C++ 등의 코드를 수행하기 위한 스택입니다._